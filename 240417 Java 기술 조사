문제 1. 객체지향 프로그래밍의 특징과 원칙에 대하여 논하시오.
특징 1. 캡슐화 (Encapsulation):
-캡슐화는 데이터와 해당 데이터를 조작하는 메서드를 하나의 단위로 묶는 것을 의미합니다.
-객체는 자신의 내부 상태를 숨기고, 외부에 공개할 인터페이스만 제공하여 객체 간의 결합도를 낮추고 재사용성을 높입니다.
-이를 통해 코드를 이해하기 쉽고 유지 보수하기 쉽도록 만듭니다.

특징 2. 상속 (Inheritance):
-상속은 기존 클래스의 특성을 그대로 물려받아 새로운 클래스를 정의하는 것을 의미합니다.
-상속을 통해 코드의 재사용성을 높일 수 있습니다. 부모 클래스의 특성을 자식 클래스에서 재사용하고 추가적인 특성을 추가할 수 있습니다.
-상속은 계층 구조를 형성하여 코드의 구조를 논리적으로 정리하고 확장성을 제공합니다.

특징 3. 다형성 (Polymorphism):
-다형성은 동일한 인터페이스를 사용하여 다른 구현을 제공할 수 있는 능력을 의미합니다.
-다형성을 통해 코드의 유연성을 높일 수 있습니다. 하나의 인터페이스로 여러 타입의 객체를 처리할 수 있어서 코드의 일반성을 유지할 수 있습니다.
-다형성은 오버로딩(Overloading)과 오버라이딩(Overriding)을 통해 구현됩니다.

특징 4. 추상화 (Abstraction):
-추상화는 객체가 가진 공통의 속성과 동작을 분석하여 모델링하는 과정을 의미합니다.
-추상화를 통해 현실 세계의 복잡성을 단순화하고, 중요한 부분만을 강조하여 문제를 해결할 수 있습니다.
-추상화는 프로그램의 복잡성을 다루기 쉽도록 만듭니다.

원칙 1. 단일 책임 원칙 (Single Responsibility Principle, SRP):
하나의 클래스는 단 하나의 책임만 가져야 합니다. 클래스가 변경되어야 하는 이유는 오직 하나여야 합니다.

원칙 2. 개방-폐쇄 원칙 (Open-Closed Principle, OCP):
소프트웨어 요소는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 합니다. 새로운 기능이 추가되거나 변경되더라도 기존의 코드는 수정되지 않아야 합니다.

원칙 3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP):
자식 클래스는 언제나 부모 클래스로 대체될 수 있어야 합니다. 즉, 부모 클래스의 인스턴스 대신에 자식 클래스의 인스턴스를 사용해도 프로그램의 의도된 동작은 변경되지 않아야 합니다.

원칙 4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP):
클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 됩니다. 즉, 클라이언트는 오직 자신이 필요한 인터페이스만을 사용해야 합니다.

원칙 5. 의존성 역전 원칙 (Dependency Inversion Principle, DIP):
고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 모두 추상화에 의존해야 합니다. 추상화는 세부 사항에 의존해서는 안 됩니다. 세부 사항이 추상화에 의존해야 합니다.



문제 2. static과 non-static의 차이에 대하여 논하시오.
static과 non-static은 객체 지향 프로그래밍에서 메서드와 변수의 특성을 나타내는데 사용되는 키워드입니다. static 멤버는 클래스 수준의 멤버로 모든 인스턴스에서 공유되고, non-static 멤버는 각각의 인스턴스에 속하는 멤버로 각 인스턴스마다 고유한 값을 가집니다.

1. static (정적):
-static 키워드가 지정된 변수나 메서드는 클래스 수준의 멤버로 각각의 인스턴스에 종속되지 않습니다.
-클래스의 모든 인스턴스가 공유하는 하나의 값 또는 동작을 나타냅니다.
-static 변수는 프로그램이 시작될 때 메모리에 할당되며, 프로그램이 종료될 때까지 유지됩니다.
-static 메서드는 인스턴스 생성 없이도 클래스 이름을 통해 호출될 수 있습니다.
-주로 상수, 공유 자원, 유틸리티 메서드 등에 사용됩니다.

2. non-static (비정적 또는 인스턴스):
-non-static 멤버는 각각의 클래스 인스턴스에 속하는 멤버로, 인스턴스마다 고유한 값을 가질 수 있습니다.
-인스턴스가 생성될 때마다 새로운 메모리 공간이 할당되며, 인스턴스의 라이프사이클에 따라 메모리가 해제됩니다.
-non-static 메서드는 반드시 해당 클래스의 인스턴스를 생성한 후에 호출할 수 있습니다.
-주로 객체의 상태를 나타내는 인스턴스 변수와 해당 인스턴스에 대한 동작을 수행하는 메서드에 사용됩니다.



문제 3. 추상 클래스와 인터페이스의 차이에 대하여 논하시오.
자바에서 추상 클래스와 인터페이스는 둘 다 추상화를 구현하기 위한 도구로 사용 되지만, 추상 클래스는 공통된 기능을 상속받은 클래스들의 구현을 재사용하고자 할 때 사용되며, 인터페이스는 클래스 간의 관계를 느슨하게 유지하고 다양한 객체들 간의 관계를 정의하고자 할 때 사용됩니다. 따라서 추상 클래스는 "is-a" 관계를, 인터페이스는 "has-a" 관계를 나타내는데 사용됩니다.

1. 추상 클래스 (Abstract Class):
-추상 클래스는 하나 이상의 추상 메서드(abstract method)를 포함할 수 있습니다. 추상 메서드는 선언만 되어 있고 구현이 없는 메서드입니다.
-추상 클래스는 추상 메서드 뿐만 아니라 구현된 메서드도 가질 수 있습니다.
-추상 클래스는 객체를 직접적으로 생성할 수 없으며, 반드시 하위 클래스에서 상속받아 추상 메서드를 구현해야 합니다.
-추상 클래스는 일반 메서드를 포함할 수 있기 때문에 공통된 구현을 재사용할 수 있습니다.

2. 인터페이스 (Interface):
-인터페이스는 오직 추상 메서드와 상수만을 포함할 수 있습니다. Java 8부터는 default 메서드와 static 메서드도 추가되었습니다.
-인터페이스의 모든 메서드는 자동으로 public이며, 구현 클래스에서 반드시 모든 메서드를 구현해야 합니다.
-인터페이스는 다중 상속을 지원하므로 여러 개의 인터페이스를 구현할 수 있습니다.
-인터페이스는 클래스 간의 결합도를 낮추고 유연한 디자인을 가능하게 합니다. 또한 API의 명세서로 사용되기도 합니다.



문제 4.프로세스와 스레드의 차이에 대하여 논하시오.
자바에서의 프로세스와 스레드는 운영체제에서의 프로세스와 스레드와 유사한 개념이지만, 자바의 실행 환경과 특성에 맞게 구현되어 있습니다. 자바에서는 멀티스레드 프로그래밍을 통해 병렬성을 활용하여 성능을 향상시키고, 동시에 여러 작업을 처리할 수 있습니다.

1. 프로세스 (Process):
-실행 중인 프로그램을 의미합니다. 각 프로세스는 독립적인 메모리 공간을 가지며, 운영체제에서는 각각의 프로세스에게 별도의 자원을 할당합니다.
-자바 어플리케이션이 실행될 때는 자바 가상 머신(Java Virtual Machine, JVM)이 프로세스로 실행됩니다. JVM은 운영체제에서 할당받은 메모리 영역 내에서 자바 어플리케이션을 실행하고 관리합니다.

2.스레드 (Thread):
-자바에서 스레드는 프로세스 내에서 실행되는 작은 실행 단위를 나타냅니다. 스레드는 프로세스의 자원을 공유하며, 프로세스 내에서 여러 개의 스레드가 동시에 실행될 수 있습니다.
-자바에서는 java.lang.Thread 클래스를 사용하여 스레드를 생성하고 관리합니다. 또한 java.util.concurrent 패키지에서는 스레드 풀을 제공하여 스레드 관리를 보다 효율적으로 할 수 있습니다.
-자바 어플리케이션은 메인 스레드(main thread)에서 시작하며, 추가적인 스레드를 생성하여 병렬로 작업을 수행할 수 있습니다.



문제 6. 싱글턴 패턴에  대하여 논하시오.
싱글턴 패턴은 디자인 패턴 중 하나로, 특정 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 패턴입니다. 이를 통해 해당 클래스의 인스턴스를 전역적으로 접근할 수 있고, 여러 곳에서 동일한 인스턴스를 공유하여 메모리를 절약하고 일관성을 유지할 수 있습니다. 



문제 7. 직렬화(Serialization)와 역직렬화(Deserialization)에 대하여 논하시오.
직렬화와 역직렬화는 객체를 바이트 스트림으로 변환하거나 바이트 스트림을 객체로 변환하는 과정을 의미합니다. 직렬화와 역직렬화는 자바의 중요한 기능 중 하나이며, 네트워크 통신에서 객체를 전송하거나 데이터를 영속화할 때 유용하게 사용됩니다. 하지만 주의할 점도 있습니다. 직렬화된 데이터는 보안 문제가 있을 수 있으며, 역직렬화 과정에서의 안전성과 성능에 영향을 줄 수 있습니다. 따라서 보안에 민감한 데이터나 대규모의 객체를 다룰 때에는 적절한 보안 및 성능 대책을 고려해야 합니다.

1. 직렬화 (Serialization):
-직렬화는 자바에서 객체를 메모리에 저장되어 있는 형태에서 데이터를 파일이나 네트워크를 통해 전송 가능한 형태로 변환하는 과정을 말합니다.
-객체를 직렬화하려면 해당 클래스가 Serializable 인터페이스를 구현해야 합니다.
-직렬화된 객체는 데이터 스트림으로 변환되어 외부 저장 매체에 저장하거나, 네트워크를 통해 다른 시스템으로 전송될 수 있습니다.

2. 역직렬화 (Deserialization):
-역직렬화는 직렬화된 데이터를 다시 객체로 변환하는 과정을 말합니다.
-역직렬화를 하려면 직렬화된 데이터와 원본 클래스의 정보가 필요합니다. 이 정보가 없으면 역직렬화가 실패합니다.
-역직렬화된 객체는 직렬화될 때의 원본 객체와 동일한 상태를 가집니다.



문제 8. 제네릭(Generic)에 대하여 논하시오.
제네릭은 자바에서 컴파일 시간에 타입을 지정할 수 있도록 하는 기능입니다. 제네릭을 사용하면 클래스나 메서드를 선언할 때 다양한 타입의 객체를 다룰 수 있으며, 타입 안정성을 보장할 수 있습니다. 이를 통해 코드의 재사용성과 유지보수성을 높일 수 있습니다.
제네릭의 장점으로는 타입 안정성(Type Safety), 코드 재사용성(Reusability), 프로그램 성능(Performance)이 있습니다.



문제 9. 박싱(Boxing)과 언박싱(Unboxing)에 대하여 논하시오.
박싱과 언박싱은 기본 데이터 타입(primitive type)과 해당하는 래퍼 클래스(wrapper class) 간의 변환을 의미합니다.

1. 박싱 (Boxing):
-박싱은 기본 데이터 타입을 해당하는 래퍼 클래스의 객체로 변환하는 과정을 말합니다.
-박싱은 자동적으로 이루어지며, 컴파일러가 자동으로 박싱 코드를 삽입합니다.

2. 언박싱 (Unboxing):
-언박싱은 래퍼 클래스의 객체를 해당하는 기본 데이터 타입으로 변환하는 과정을 말합니다.
-언박싱 역시 자동적으로 이루어지며, 컴파일러가 자동으로 언박싱 코드를 삽입합니다.



문제 10. 람다식(Lambda)에 대하여 논하시오.
람다식(Lambda expression)은 자바 8부터 도입된 기능으로, 함수형 프로그래밍을 지원하기 위한 중요한 요소입니다. 람다식은 익명 함수(anonymous function)의 형태로 간결하게 표현할 수 있습니다.  람다식을 사용하면 함수를 한 줄로 간결하게 표현할 수 있으며, 함수를 변수에 저장하거나 다른 함수의 매개변수로 전달할 수 있습니다.
